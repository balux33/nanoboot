#include <stdint.h>
#include <cache.h>
#include <lib.c>
#include "puff.h"
#include <setjmp.h>
#include "crc32.h"

extern int image_main(void);
extern void image_load_base(void);
extern void image_load_end(void);
extern void packed_base(void);
extern void packed_end(void);

// footer below the deflate data
struct __attribute__((packed)) footer {
	// from original GZIP footer
	uint32_t destcrc;
	uint32_t destlen;
	// generated by gzip2deflate.pl
	uint32_t srccrc;
};

int main(void) {
	struct footer *footer = (void *) (packed_end - sizeof(struct footer));
	unsigned long packed_size = packed_end - packed_base;
	puff_init();
	crc32_init();

	// check source CRC first. if source data is corrupted, compression
	// could behave erratically.
	uint32_t srccrc = crc32(packed_base, packed_size - sizeof(uint32_t));
	if (srccrc != footer->srccrc) {
		printf("error: input crc mismatch %08x != %08x\n",
				srccrc, footer->srccrc);
		return 1;
	}
	
	// unpack the data; this must be successful as well
	unsigned long destlen;
	unsigned long srclen;
	int err = puff((void *) image_load_base, &destlen,
			(void *) packed_base, &srclen);
	if (err != 0) {
		printf("error: decompression status %d\n", err);
		return 1;
	}
	// check that all input was consumed and all output generated
	if (srclen != packed_size - sizeof(struct footer)) {
		printf("error: input length mismatch %d != %d\n",
				srclen, packed_size - sizeof(struct footer));
		return 1;
	}
	if (destlen != footer->destlen) {
		printf("error: output length mismatch %d != %d\n",
				destlen, footer->destlen);
		return 1;
	}
	
	// check destination CRC, for good measure.
	uint32_t destcrc = crc32(image_load_base, destlen);
	if (destcrc != footer->destcrc) {
		printf("error: output crc mismatch %08x != %08x\n",
				destcrc, footer->destcrc);
		return 1;
	}

	// flush cache so that the data is actually in memory. Icache cannot
	// fill from Dcache, so for short images we could otherwise end up
	// executing uninitialized memory.
	cache_flush();
	
	// if everything is fine, call the decompressed image.
	return image_main();
}
